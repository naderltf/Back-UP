# -*- coding: utf-8 -*-
"""DosScript.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b2DI2-0v9sjMnW4AenfE8049elzb1kGO
"""

!python -m pip install pyyaml==5.1
import sys, os, distutils.core
# Note: This is a faster way to install detectron2 in Colab, but it does not include all functionalities.
# See https://detectron2.readthedocs.io/tutorials/install.html for full installation instructions
!git clone 'https://github.com/facebookresearch/detectron2'
dist = distutils.core.run_setup("./detectron2/setup.py")
!python -m pip install {' '.join([f"'{x}'" for x in dist.install_requires])}
sys.path.insert(0, os.path.abspath('./detectron2'))

from matplotlib import pyplot as plt
import torch, detectron2
!nvcc --version
TORCH_VERSION = ".".join(torch.__version__.split(".")[:2])
CUDA_VERSION = torch.__version__.split("+")[-1]
print("torch: ", TORCH_VERSION, "; cuda: ", CUDA_VERSION)
print("detectron2:", detectron2.__version__)

import detectron2
from detectron2.utils.logger import setup_logger
setup_logger()

# import some common libraries
import numpy as np
import os, json, cv2, random
from matplotlib import  pyplot as plt
from google.colab.patches import cv2_imshow

# import some common detectron2 utilities
from detectron2 import model_zoo
from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2.utils.visualizer import Visualizer
from detectron2.data import MetadataCatalog, DatasetCatalog

from scipy.spatial import distance

import math

def calculate_angle_of_intersection(x1, y1, x2, y2, x3, y3, x4, y4):
    # Calculate the slopes of the two lines
    slope1 = (y2 - y1) / (x2 - x1) if x2 != x1 else float('inf')  # Handle vertical line
    slope2 = (y4 - y3) / (x4 - x3) if x4 != x3 else float('inf')  # Handle vertical line

    # Calculate the angle of intersection
    angle = math.atan(abs((slope2 - slope1) / (1 + slope1 * slope2)))

    return math.degrees(angle)

class Dos:

    def __init__(self,linearity_pred=None,pockets_pred=None) -> None:

          self.linearity_model_path = '/content/drive/MyDrive/FD/linearity.pth'
          self.poche_model_path = '/content/drive/MyDrive/FD/poches.pth'

           #linearity predictor
          self.linearity_predictor = linearity_pred if linearity_pred is not None else self.linearity_cfg()
          #pockets predictor
          self.pockets_predictor = pockets_pred if pockets_pred is not None else self.pockets_cfg()


    def to_int(self,data):
      if type(data)==list or type(data)==tuple:
          new_data=[int(datum) for datum in data]
          return new_data

    def draw_point(self,image,color,point:tuple,radius):
      radius = radius
      color = color
      thickness = 2
      point=self.to_int(point)
      image = cv2.circle(image, point, radius, color, thickness)
      return image

    def draw_box(self,image,start_point,end_point):
      color = (255, 0, 0)
      thickness = 2
      image = cv2.rectangle(image, start_point, end_point, color, thickness)
      return image

    def draw_line(self,image,start_point, end_point):
      color = (0, 255, 255)
      thickness = 3
      image = cv2.line(image, start_point, end_point, color, thickness)
      return image

    def add_text(self,image,text,point,color,fontScale):
        #point : coordinates where to put the text
        font = cv2.FONT_HERSHEY_SIMPLEX
        fontScale = fontScale
        color = color
        thickness = 2
        image = cv2.putText(image, text, point, font,
                          fontScale, color, thickness, cv2.LINE_AA)
        return image


    def linearity_cfg(self):
        cfg = get_cfg()
        cfg.MODEL.DEVICE = 'cpu'
        cfg.merge_from_file(model_zoo.get_config_file("COCO-Keypoints/keypoint_rcnn_R_50_FPN_3x.yaml"))

        cfg.MODEL.ROI_HEADS.NUM_CLASSES = 1 # hand
        cfg.MODEL.RETINANET.NUM_CLASSES = 1
        cfg.MODEL.ROI_KEYPOINT_HEAD.NUM_KEYPOINTS = 3

        cfg.MODEL.WEIGHTS = self.linearity_model_path
        cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.89 # set a custom testing threshold
        predictor = DefaultPredictor(cfg)
        return predictor

    def pockets_cfg(self):
      cfg = get_cfg()
      cfg.MODEL.DEVICE = 'cpu'
      cfg.merge_from_file(model_zoo.get_config_file("COCO-Keypoints/keypoint_rcnn_R_101_FPN_3x.yaml"))

      cfg.MODEL.ROI_HEADS.NUM_CLASSES = 3 # hand
      cfg.MODEL.RETINANET.NUM_CLASSES = 3
      cfg.MODEL.ROI_KEYPOINT_HEAD.NUM_KEYPOINTS = 5

      cfg.MODEL.WEIGHTS =  self.poche_model_path
      cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.89 # set a custom testing threshold
      predictor = DefaultPredictor(cfg)
      return predictor

    def calculate_angle_of_intersection(self,x1, y1, x2, y2, x3, y3, x4, y4):
        # Calculate the slopes of the two lines
        slope1 = (y2 - y1) / (x2 - x1) if x2 != x1 else float('inf')  # Handle vertical line
        slope2 = (y4 - y3) / (x4 - x3) if x4 != x3 else float('inf')  # Handle vertical line

        # Calculate the angle of intersection
        angle = math.atan(abs((slope2 - slope1) / (1 + slope1 * slope2)))

        return math.degrees(angle)

    def getResult(self,image,predictor):
        outputs = predictor(image)
        o = outputs["instances"]
        v = Visualizer(image[:, :, ::-1],

                      scale=0.8  # remove the colors of unsegmented pixels
        )
        v = v.draw_instance_predictions(outputs["instances"].to('cpu'))
        image_with_detected_defects=v.get_image()
        return image_with_detected_defects,o

    def check_inclination(self,image,p1,p2,o):
      """
      p1 : a or e of left pocket
      p2: a or e of right pocket
      o : middle point of belt , the reference of comparaison
      """
      x1,y1=p1
      x2,y2=p2
      x0=o[0]
      symetrique="poches symetriques"
      if y1 < y2:
        result_y = 'left higher'
        symetrique="poches non symetriques"
      elif y1 > y2:
        result_y = "right higher"
        symetrique="poches non symetriques"
      if int(x1-x0) < int(x2-x0):
        result_x = "left closer"
        symetrique="poches non symetriques"
      elif int(x1-x0) > int(x2-x0):
        result_x = "right closer"
        symetrique="poches non symetriques"
      #visualization part
      image=self.draw_point(image,(0,0,255),p1,2)
      image=self.draw_point(image,(0,0,255),p2,2)
      image=self.draw_point(image,(0,0,255),o,2)
      return result_x,result_y,image,symetrique

    def retrieve_kpts(self,cls_wanted,classes,kpts):
      class_index=classes.index(cls_wanted)
      class_kpts=kpts[class_index]
      a,b,c,d,e=class_kpts
      a=a[0:2]
      b=b[0:2]
      c=c[0:2]
      d=d[0:2]
      e=e[0:2]
      return a,b,c,d,e

    def getIncliResult(self):
      #process left pocket
      a0,b0,c0,d0,e0=self.retrieve_kpts(0,self.pockets_cls.tolist(),self.pockets_kpts.tolist())
      #process right pocket
      a1,b1,c1,d1,e1=self.retrieve_kpts(1,self.pockets_cls.tolist(),self.pockets_kpts.tolist())
      #mesure
      a0_e0 = distance.euclidean(self.to_int(a0),self.to_int(e0))
      a1_e1 = distance.euclidean(self.to_int(a1),self.to_int(e1))
      a0_b0 = distance.euclidean(self.to_int(a0),self.to_int(b0))
      a1_b1 = distance.euclidean(self.to_int(a1),self.to_int(b1))
      #process belt
      _,__,o,___,____=self.retrieve_kpts(2,self.pockets_cls.tolist(),self.pockets_kpts.tolist())
      result_x,result_y,im,symetrique=self.check_inclination(self.image_brut,e0,a1,o)

      im=self.draw_point(im,(0,0,255),self.to_int(a0),2)
      im=self.draw_point(im,(0,0,255),self.to_int(e0),2)
      im=self.draw_point(im,(0,0,255),self.to_int(b0),2)

      im=self.draw_point(im,(0,0,255),self.to_int(a1),2)
      im=self.draw_point(im,(0,0,255),self.to_int(b1),2)
      im=self.draw_point(im,(0,0,255),self.to_int(e1),2)

      im=self.draw_line(im,self.to_int(a0), self.to_int(e0))
      im=self.draw_line(im,self.to_int(a0), self.to_int(e0))
      im=self.draw_line(im,self.to_int(a1), self.to_int(e1))
      im=self.draw_line(im,self.to_int(a1), self.to_int(b1))

      im=self.add_text(im,str(int(a0_e0)),(self.to_int(a0)[0]+140,self.to_int(a0)[1]),(255,255,255),2)
      im=self.add_text(im,str(int(a0_b0)),(self.to_int(a0)[0],self.to_int(a0)[1]+120),(255,255,255),2)
      im=self.add_text(im,str(int(a1_e1)),(self.to_int(a1)[0]+140,self.to_int(a1)[1]),(255,255,255),2)
      im=self.add_text(im,str(int(a1_b1)),(self.to_int(a1)[0],self.to_int(a1)[1]+120),(255,255,255),2)

      return result_x,result_y,im,e0,a1,o,symetrique

    def showResultOnScreen(self,o,p1,p2,image,resultX,resultY):
      """
      o is origin point : middle point of belt
      p1 left pocket , p2 right
      """
      # X part
      repere1 = self.to_int((o[0],p1[1]))
      repere2 = self.to_int((o[0],p2[1]))
      axis_X = [ self.to_int(o), self.to_int((o[0],1000)) ]

      img=self.draw_line(image,self.to_int(o), axis_X[1])
      img=self.draw_line(img,self.to_int(p1),repere1)
      img=self.draw_line(img,self.to_int(p2),repere2)

      diff1 = int(p1[0] - o[0])
      diff2 = int(p2[0] - o[0])

      img=self.add_text(img,str(diff1),self.to_int(p1),(255,0,0),1)
      img=self.add_text(img,str(diff2),self.to_int(p2),(255,0,0),1)
      img=self.add_text(img,resultX,(repere1[0],repere1[1]+100),(255,0,0),1)

      # Y part
      repere1 = self.to_int((p1[0],o[1]))
      repere2 = self.to_int((p2[0],o[1]))
      axis_Y = [self.to_int((1000,o[1])), self.to_int((0,o[1])) ]

      img=self.draw_line(img,axis_Y[0], axis_Y[1])
      img=self.draw_line(img,self.to_int(p1),repere1)
      img=self.draw_line(img,self.to_int(p2),repere2)

      diff1 = int(p1[1] - o[1])
      diff2 = int(p2[1] - o[1])

      img=self.add_text(img,str(diff1),self.to_int((p1[0],o[1]+50)),(255,0,0),1)
      img=self.add_text(img,str(diff2),self.to_int((p2[0],o[1]+50)),(255,0,0),1)
      img=self.add_text(img,resultY,repere1,(255,0,0),1)
      return img

    def process(self,imgPATH):
      self.image_brut = cv2.imread(imgPATH)
      self.img_linearity,o_linearity=self.getResult(self.image_brut,self.linearity_predictor)
      self.linearity_kpts=o_linearity.get('pred_keypoints')
      self.linearity_cls=o_linearity.get('pred_classes')
                #pockets result
      self.img_pockets,o_pockets=self.getResult(self.image_brut,self.pockets_predictor)
      self.pockets_kpts=o_pockets.get('pred_keypoints')
      self.pockets_cls=o_pockets.get('pred_classes')

      x1,y1=self.linearity_kpts.tolist()[0][0][0:2]
      x2,y2=self.linearity_kpts.tolist()[0][1][0:2]
      x2=x2+0.00000000001
      x3,y3=self.linearity_kpts.tolist()[0][2][0:2]
      x4,y4=x3+2,y3

      self.angle = self.calculate_angle_of_intersection(x1, y1, x2, y2, x3, y3, x4, y4)
      self.result_x,self.result_y,image,e0,a1,o,symetrique=self.getIncliResult()

      print("ooooooooo",o,e0,a1)
      image = self.showResultOnScreen(o,e0,a1,image,self.result_x,self.result_y)
      image = self.add_text(image,str(int(self.angle)),self.to_int((x2,y2)),(255,0,0),1)

      """
      drawing the result on the right
      """
      wid,hei,c=image.shape
      zone_for_writing = (wid-150,hei+150)

      image=cv2.rectangle(image, (2400, 0+150), (2900, 0+360), (40, 40, 40), -10)
      image = self.add_text(image,"linearity of the FD is"+str(round(self.angle,2)),(2420,180),(255,0,255),1)
      image = self.add_text(image,self.result_x,(2420,240),(255,0,255),1)
      image = self.add_text(image,self.result_y,(2420,300),(255,0,255),1)
      image = self.add_text(image,symetrique,(2420,340),(255,0,255),1)


      return {
         "angle" : self.angle,
         "resX" : self.result_x,
         "resY" : self.result_y,
         "image" : image
      }

roadToImage='/content/drive/MyDrive/FD_Fixed/001003980775_DENIM HOUSE+1_SARTEX.jpg'
dos=Dos()
result_dict=dos.process(roadToImage)
angle=result_dict['angle']
resX=result_dict['resX']
resY=result_dict['resY']
img=result_dict['image']
print(angle,resX,resY)
cv2_imshow(img)

def showPredict(image,lst_points,lst_bxs):
  """
  lst_points => points predicted by the models passed as a list
  same for the lst_bxs
  """
  img=image
  for bx in lst_bxs:
    bx=to_int(bx)
    x1,y1,w,h=bx
    x2,y2=x1+w,y1+h
    start_point=(x1,y1)
    end_pt=(x2,y2)
    draw_box(img,start_point,end_point)

  for pts in lst_points :
    img=draw_point(img,point)

  return img

def visualizeResult(image,predictor):
    outputs = predictor(image)
    o = outputs["instances"]
    v = Visualizer(image[:, :, ::-1],

                   scale=0.8  # remove the colors of unsegmented pixels
    )
    v = v.draw_instance_predictions(outputs["instances"].to('cpu'))
    image_with_detected_defects=v.get_image()
    return image_with_detected_defects,o

def to_int(data):
    if type(data)==list or type(data)==tuple:
        new_data=[int(datum) for datum in data]
        return new_data

def draw_point(image,color,point:tuple,radius):
  radius = radius
  color = color
  thickness = 2
  point=to_int(point)
  image = cv2.circle(image, point, radius, color, thickness)
  return image

def draw_box(image,start_point,end_point):
  color = (255, 0, 0)
  thickness = 2
  image = cv2.rectangle(image, start_point, end_point, color, thickness)
  return image

def draw_line(image,start_point, end_point):
  color = (0, 255, 255)
  thickness = 3
  image = cv2.line(image, start_point, end_point, color, thickness)
  return image

def add_text(image,text,point):
    #point : coordinates where to put the text
    font = cv2.FONT_HERSHEY_SIMPLEX
    fontScale = 1
    color = (255, 0, 0)
    thickness = 2
    image = cv2.putText(image, text, coordinates, font,
                      fontScale, color, thickness, cv2.LINE_AA)
    return image

#linearity model cfg
def linearity_cfg(linearity_model_path):
    cfg = get_cfg()
    cfg.MODEL.DEVICE = 'cpu'
    cfg.merge_from_file(model_zoo.get_config_file("COCO-Keypoints/keypoint_rcnn_R_50_FPN_3x.yaml"))

    cfg.MODEL.ROI_HEADS.NUM_CLASSES = 1 # hand
    cfg.MODEL.RETINANET.NUM_CLASSES = 1
    cfg.MODEL.ROI_KEYPOINT_HEAD.NUM_KEYPOINTS = 3

    cfg.MODEL.WEIGHTS = linearity_model_path
    cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.89 # set a custom testing threshold
    predictor = DefaultPredictor(cfg)
    return predictor

#pockets model cfg
def pockets_cfg(poche_model_path):
    cfg = get_cfg()
    cfg.MODEL.DEVICE = 'cpu'
    cfg.merge_from_file(model_zoo.get_config_file("COCO-Keypoints/keypoint_rcnn_R_101_FPN_3x.yaml"))

    cfg.MODEL.ROI_HEADS.NUM_CLASSES = 3 # hand
    cfg.MODEL.RETINANET.NUM_CLASSES = 3
    cfg.MODEL.ROI_KEYPOINT_HEAD.NUM_KEYPOINTS = 5

    cfg.MODEL.WEIGHTS = poche_model_path
    cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.89 # set a custom testing threshold
    predictor = DefaultPredictor(cfg)
    return predictor

linearity_model_path = '/content/drive/MyDrive/FD/linearity.pth'
poche_model_path = '/content/drive/MyDrive/FD/poches.pth'

image_path="/content/drive/MyDrive/FD_Fixed/294.jpg"
image=cv2.imread(image_path)

#linearity predictor
linearity_predictor = linearity_cfg(linearity_model_path)

#pockets predictor
pockets_predictor = pockets_cfg(poche_model_path)

#linearity result
img_linearity,o_linearity=visualizeResult(image,linearity_predictor)
linearity_kpts=o_linearity.get('pred_keypoints')
linearity_cls=o_linearity.get('pred_classes')
#pockets result
img_pockets,o_pockets=visualizeResult(image,pockets_predictor)
pockets_kpts=o_pockets.get('pred_keypoints')
pockets_cls=o_pockets.get('pred_classes')

def draw_pots(image,lst_pts):
  colors=[
      (255,0,0),
      (0,255,0),
      (0,0,255),
      (255,255,0),
      (0,255,255)
  ]
  indx_color=0
  for i in lst_pts:
    indx_color=0
    for pt in i:
      p=tuple(pt[0:2])
      color=colors[indx_color]
      image=draw_point(image,color,p,20)
      indx_color+=1
  return image

img=draw_pots(image,pockets_kpts.tolist())

cv2_imshow(img)

cv2_imshow(img_linearity)

linearity_kpts.tolist()

def draw_lin_pts(image,kpts):
  colors=[
      (255,255,0),
      (0,255,0),
      (0,0,255)
  ]
  indx_color=0
  for i in kpts:
    indx_color=0
    for pt in i:
      p=tuple(pt[0:2])
      color=colors[indx_color]
      image=draw_point(image,color,p,20)
      indx_color+=1
  return image

image_fd=draw_lin_pts(image,linearity_kpts)

cv2_imshow(image_fd)

x1,y1=linearity_kpts.tolist()[0][0][0:2]
x2,y2=linearity_kpts.tolist()[0][1][0:2]
x2=x2+0.00000000001
x3,y3=linearity_kpts.tolist()[0][2][0:2]
x4,y4=x3+2,y3

print(x1,y1)

angle = calculate_angle_of_intersection(x1, y1, x2, y2, x3, y3, x4, y4)
print(f"The angle of intersection between the two lines is {angle} degrees.")

a,b,c,d,e=pockets_kpts.tolist()[1]
a,b,c,d,e

pockets_cls.tolist()

def retrieve_kpts(cls_wanted,classes,kpts):
  class_index=classes.index(cls_wanted)
  class_kpts=kpts[class_index]
  a,b,c,d,e=class_kpts
  a=a[0:2]
  b=b[0:2]
  c=c[0:2]
  d=d[0:2]
  e=e[0:2]
  return a,b,c,d,e

def check_inclination(image,p1,p2,o):
  """
  p1 : a or e of left pocket
  p2: a or e of right pocket
  o : middle point of belt , the reference of comparaison
  """
  x1,y1=p1
  x2,y2=p2
  x0=o[0]
  if y1 < y2:
    result_y = 'left higher'

  elif y1 > y2:
    result_y = "right higher"

  if int(x1-x0) < int(x2-x0):
    result_x = "left closer"
  elif int(x1-x0) > int(x2-x0):
    result_x = "right closer"


  #visualization part
  image=draw_point(image,(0,0,255),p1,2)
  image=draw_point(image,(0,0,255),p2,2)
  image=draw_point(image,(0,0,255),o,2)

  return result_x,result_y,image

def process():
  #process left pocket
  a0,b0,c0,d0,e0=retrieve_kpts(0,pockets_cls.tolist(),pockets_kpts.tolist())
  #process right pocket
  a1,b1,c1,d1,e1=retrieve_kpts(1,pockets_cls.tolist(),pockets_kpts.tolist())
  #process belt
  _,__,o,___,____=retrieve_kpts(2,pockets_cls.tolist(),pockets_kpts.tolist())
  result_x,result_y,im=check_inclination(image,e0,a1,o)

  return result_x,result_y,im

result_x,result_y,image=process()

result_x,result_y

cv2_imshow(image)

class Dos:

    def __init__(self,image_path,linearity_pred=None,pockets_pred=None) -> None:

          self.linearity_model_path = '/content/drive/MyDrive/FD/linearity.pth'
          self.poche_model_path = '/content/drive/MyDrive/FD/poches.pth'
          self.image_brut=cv2.imread(image_path)
           #linearity predictor
          self.linearity_predictor = linearity_pred if linearity_pred is not None else self.linearity_cfg()
          #pockets predictor
          self.pockets_predictor = pockets_pred if pockets_pred is not None else self.pockets_cfg()


    def to_int(self,data):
      if type(data)==list or type(data)==tuple:
          new_data=[int(datum) for datum in data]
          return new_data

    def draw_point(self,image,color,point:tuple,radius):
      radius = radius
      color = color
      thickness = 2
      point=self.to_int(point)
      image = cv2.circle(image, point, radius, color, thickness)
      return image

    def draw_box(self,image,start_point,end_point):
      color = (255, 0, 0)
      thickness = 2
      image = cv2.rectangle(image, start_point, end_point, color, thickness)
      return image

    def draw_line(self,image,start_point, end_point):
      color = (0, 255, 255)
      thickness = 3
      image = cv2.line(image, start_point, end_point, color, thickness)
      return image

    def add_text(self,image,text,point):
        #point : coordinates where to put the text
        font = cv2.FONT_HERSHEY_SIMPLEX
        fontScale = 1
        color = (255, 0, 0)
        thickness = 2
        image = cv2.putText(image, text, point, font,
                          fontScale, color, thickness, cv2.LINE_AA)
        return image


    def linearity_cfg(self):
        cfg = get_cfg()
        cfg.MODEL.DEVICE = 'cpu'
        cfg.merge_from_file(model_zoo.get_config_file("COCO-Keypoints/keypoint_rcnn_R_50_FPN_3x.yaml"))

        cfg.MODEL.ROI_HEADS.NUM_CLASSES = 1 # hand
        cfg.MODEL.RETINANET.NUM_CLASSES = 1
        cfg.MODEL.ROI_KEYPOINT_HEAD.NUM_KEYPOINTS = 3

        cfg.MODEL.WEIGHTS = self.linearity_model_path
        cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.89 # set a custom testing threshold
        predictor = DefaultPredictor(cfg)
        return predictor

    def pockets_cfg(self):
      cfg = get_cfg()
      cfg.MODEL.DEVICE = 'cpu'
      cfg.merge_from_file(model_zoo.get_config_file("COCO-Keypoints/keypoint_rcnn_R_101_FPN_3x.yaml"))

      cfg.MODEL.ROI_HEADS.NUM_CLASSES = 3 # hand
      cfg.MODEL.RETINANET.NUM_CLASSES = 3
      cfg.MODEL.ROI_KEYPOINT_HEAD.NUM_KEYPOINTS = 5

      cfg.MODEL.WEIGHTS =  self.poche_model_path
      cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.89 # set a custom testing threshold
      predictor = DefaultPredictor(cfg)
      return predictor

    def calculate_angle_of_intersection(self,x1, y1, x2, y2, x3, y3, x4, y4):
        # Calculate the slopes of the two lines
        slope1 = (y2 - y1) / (x2 - x1) if x2 != x1 else float('inf')  # Handle vertical line
        slope2 = (y4 - y3) / (x4 - x3) if x4 != x3 else float('inf')  # Handle vertical line

        # Calculate the angle of intersection
        angle = math.atan(abs((slope2 - slope1) / (1 + slope1 * slope2)))

        return math.degrees(angle)

    def getResult(self,image,predictor):
        outputs = predictor(image)
        o = outputs["instances"]
        v = Visualizer(image[:, :, ::-1],

                      scale=0.8  # remove the colors of unsegmented pixels
        )
        v = v.draw_instance_predictions(outputs["instances"].to('cpu'))
        image_with_detected_defects=v.get_image()
        return image_with_detected_defects,o

    def check_inclination(self,image,p1,p2,o):
      """
      p1 : a or e of left pocket
      p2: a or e of right pocket
      o : middle point of belt , the reference of comparaison
      """
      x1,y1=p1
      x2,y2=p2
      x0=o[0]
      if y1 < y2:
        result_y = 'left higher'

      elif y1 > y2:
        result_y = "right higher"

      if int(x1-x0) < int(x2-x0):
        result_x = "left closer"
      elif int(x1-x0) > int(x2-x0):
        result_x = "right closer"
      #visualization part
      image=self.draw_point(image,(0,0,255),p1,2)
      image=self.draw_point(image,(0,0,255),p2,2)
      image=self.draw_point(image,(0,0,255),o,2)
      return result_x,result_y,image

    def retrieve_kpts(self,cls_wanted,classes,kpts):
      class_index=classes.index(cls_wanted)
      class_kpts=kpts[class_index]
      a,b,c,d,e=class_kpts
      a=a[0:2]
      b=b[0:2]
      c=c[0:2]
      d=d[0:2]
      e=e[0:2]
      return a,b,c,d,e

    def getIncliResult(self):
      #process left pocket
      a0,b0,c0,d0,e0=self.retrieve_kpts(0,self.pockets_cls.tolist(),self.pockets_kpts.tolist())
      #process right pocket
      a1,b1,c1,d1,e1=self.retrieve_kpts(1,self.pockets_cls.tolist(),self.pockets_kpts.tolist())
      #process belt
      _,__,o,___,____=self.retrieve_kpts(2,self.pockets_cls.tolist(),self.pockets_kpts.tolist())
      result_x,result_y,im=self.check_inclination(self.image_brut,e0,a1,o)

      return result_x,result_y,im,e0,a1,o

    def showResultOnScreen(self,o,p1,p2,image,resultX,resultY):
      """
      o is origin point : middle point of belt
      p1 left pocket , p2 right
      """
      # X part
      repere1 = self.to_int((o[0],p1[1]))
      repere2 = self.to_int((o[0],p2[1]))
      axis_X = [ self.to_int(o), self.to_int((o[0],1000)) ]

      img=self.draw_line(image,self.to_int(o), axis_X[1])
      img=self.draw_line(img,self.to_int(p1),repere1)
      img=self.draw_line(img,self.to_int(p2),repere2)

      diff1 = int(p1[0] - o[0])
      diff2 = int(p2[0] - o[0])

      img=self.add_text(img,str(diff1),self.to_int(p1))
      img=self.add_text(img,str(diff2),self.to_int(p2))
      img=self.add_text(img,resultX,(repere1[0],repere1[1]+100))

      # Y part
      repere1 = self.to_int((p1[0],o[1]))
      repere2 = self.to_int((p2[0],o[1]))
      axis_Y = [self.to_int((1000,o[1])), self.to_int((0,o[1])) ]

      img=self.draw_line(img,axis_Y[0], axis_Y[1])
      img=self.draw_line(img,self.to_int(p1),repere1)
      img=self.draw_line(img,self.to_int(p2),repere2)

      diff1 = int(p1[1] - o[1])
      diff2 = int(p2[1] - o[1])

      img=self.add_text(img,str(diff1),self.to_int((p1[0],o[1]+50)))
      img=self.add_text(img,str(diff2),self.to_int((p2[0],o[1]+50)))
      img=self.add_text(img,resultY,repere1)
      return img

    def process(self):
      self.img_linearity,o_linearity=self.getResult(self.image_brut,self.linearity_predictor)
      self.linearity_kpts=o_linearity.get('pred_keypoints')
      self.linearity_cls=o_linearity.get('pred_classes')
                #pockets result
      self.img_pockets,o_pockets=self.getResult(self.image_brut,self.pockets_predictor)
      self.pockets_kpts=o_pockets.get('pred_keypoints')
      self.pockets_cls=o_pockets.get('pred_classes')

      x1,y1=self.linearity_kpts.tolist()[0][0][0:2]
      x2,y2=self.linearity_kpts.tolist()[0][1][0:2]
      x2=x2+0.00000000001
      x3,y3=self.linearity_kpts.tolist()[0][2][0:2]
      x4,y4=x3+2,y3

      self.angle = self.calculate_angle_of_intersection(x1, y1, x2, y2, x3, y3, x4, y4)
      self.result_x,self.result_y,image,e0,a1,o=self.getIncliResult()

      print("ooooooooo",o,e0,a1)
      image = self.showResultOnScreen(o,e0,a1,image,self.result_x,self.result_y)
      image = self.add_text(image,str(int(self.angle)),self.to_int((x2,y2)))


      return {
         "angle" : self.angle,
         "resX" : self.result_x,
         "resY" : self.result_y,
         "image" : image
      }

roadToImage='/content/drive/MyDrive/FD_Fixed/IMG_20221210_091102.jpg'
dos=Dos(roadToImage)

result_dict=dos.process()

angle=result_dict['angle']
resX=result_dict['resX']
resY=result_dict['resY']
img=result_dict['image']
print(angle,resX,resY)
cv2_imshow(img)

def to_int(self,data):
      if type(data)==list or type(data)==tuple:
          new_data=[int(datum) for datum in data]
          return new_data

def draw_point(self,image,color,point:tuple,radius):
      radius = radius
      color = color
      thickness = 2
      point=self.to_int(point)
      image = cv2.circle(image, point, radius, color, thickness)
      return image

def draw_box(self,image,start_point,end_point):
      color = (255, 0, 0)
      thickness = 2
      image = cv2.rectangle(image, start_point, end_point, color, thickness)
      return image

def draw_line(self,image,start_point, end_point):
      color = (0, 255, 255)
      thickness = 3
      image = cv2.line(image, start_point, end_point, color, thickness)
      return image

def add_text(self,image,text,point):
        #point : coordinates where to put the text
        font = cv2.FONT_HERSHEY_SIMPLEX
        fontScale = 1
        color = (255, 0, 0)
        thickness = 2
        image = cv2.putText(image, text, point, font,
                          fontScale, color, thickness, cv2.LINE_AA)
        return image

origin=[512.7145385742188, 139.7667236328125]
left_pocket_extrem=[436.1207580566406, 308.860595703125]
right_pocket_extrem=[575.1534423828125, 302.7569885253906]

